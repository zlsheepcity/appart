<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>gene ball</title>
    <script>
        const log = (...msg) => console.log(...msg)
        const msg = msg => console.log('..', msg)
        const tab = msg => console.table({...msg})
    </script>
</head>
<body>
    <pre>
        ABPT
        RGFH
    </pre>
    <script src="geneball--libs.js"></script>
    <script>
        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ The World

        const NobleWorld = function NobleWorldFactory
        (dna) {
            const World = Object.assign(this,dna)
            World.Story = [World.name||'MainController',{dna}]
            World.SayHi = f=> log({Hi:World.Story[0], ...World})

            World.GivesPassportFor = data => {
                let name = data.name || data.toString() || 'Aita'
                return {name}
            };

            World.DisplaysNuke = (...o) => o.map( oO =>{
                console.group(oO.name)
                for (i in oO.nuke) log(i, oO.nuke[i])
                console.groupEnd(oO.name)
            });

            //World.Takes = oO => Gen.Take(oO)
        };
        let TheWorld = new NobleWorld()
        TheWorld.SayHi()

        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Genetics

        const fromGeneticsLibrary2 = function
        (dna) {
            let Gen = Object.assign(this,dna)
            Gen.SEED = 'RGFH'
            Gen.Stimul = oO => StimulFrom(oO)
            let StimulFrom = oO => ({G:2,H:7})
            Gen.Take = oO => Object.assign(oO,Gen)
            Gen.Nuke = oO => oO && oO.nuke || {G:[],H:[]}
            Gen.nuke = {G:[],H:[]}

//            Gen.AcidWeed = acid => {
//                let AcidThreesome = abc => {
//                    let [a,b,c] = abc
//                    let h = Gen.PairLoveStimul
//                    let friendly = h(c,b) > 1
//                    let winner =
//                      1 < h(c,a) && Math.random()*h(c,a)
//                        > Math.random()*h(b,a)
//                        ? c:b;
//                    return friendly ? [b,c] : [winner] ;
//                    };
//                return acid.reduce(
//                    (w,g) => {
//                        if (!w.length) return [g];
//                        let base = [w[0][0],w[0][0],w[0][0],w[0][0]].join('')
//                        let last = w.slice(-1)[0]
//                        let home = w.length >1 ? w.slice(-2)[0] :base
//                        return [
//                          ...w.slice(0, -1),
//                          ...AcidThreesome([ home, last, g ])
//                        ];
//                    }, []);
//            };
    Gen.GeneMask =
        o => [...Gen.Gene()]
               .fill(o||'O')
                .join('');

    Gen.AcidWeed = acid => acid.reduce(
        (AcW,G) => {
            const b = Gen.GeneMask(AcW[0] && AcW[0][0])
            const h = AcW.length >1 ? AcW.slice(-2)[0]:b
            const r = AcW.slice(0, -1)
            const g = AcW.slice(-1)[0]
            const f = Gen.AcidThreesome
            return !!!AcW.length? [G] :[...r,...f(h,g,G)];
        },[]);

    Gen.AcidThreesome =
    (a,b,c) => {
        if (Array.isArray(a)) [a,b,c] = a
        let h = Gen.PairLoveStimul
        let friendly = h(c,b) > 1
        let winner =
          1 < h(c,a) && Math.random()*h(c,a)
            > Math.random()*h(b,a)
            ? c:b;
        return friendly ? [b,c] : [winner] ;
        };

            Gen.Fill = oO => Oo => {
                const acid = G => Gen.AcidWeed([...oO.nuke[G], ...Oo.nuke[G]])
                Object.keys(Oo.nuke).map( G=> {oO.nuke[G]=acid(G)} )
            }
            Gen.Nuke = oO => {
                const  r = [...Gen.SEED]
                const  g = x => x.reduce(f, {})
                const  f = (a,G) => (a[G]=h(G),a)
                const  h = G => [Gen.Gene(G)]
                return oO && oO.nuke || g(r);
                };
            Gen.Gene = base => {
                const  r = Gen.SEED
                const  g = r => h[0]+f(h+r)+f(h+r)+f(h+r)
                const  f = x => x[Math.floor( Math.random()*x.length )]
                const  h = base || f(r)
                return g(r);
                };

            Gen.BasedSeed = base => {
                const eed = Gen.SEED
                const src = Gen.SEED
                const f = x => x[Math.floor( Math.random()*x.length )]
                const h = base || f(src)
                const r = (p,g) => !p? h :p +f(h+src)
                return [...eed].reduce(r,'') ;};

            Gen.PairLoveStimul =
                (AAAA,BBBB) => [...AAAA].reduce(
                    (p,g,i) => BBBB[i] === g? ++p :p
                        ,0);

            Gen.Welcome = o =>
                Object.assign( o,{
                    nuke: Gen.Nuke(),
                    Fill: function (oO, keys) {
                        (keys || Object.keys(this.nuke))
                        .map( G => {
                            let fill = {nuke:{ [G]:this.nuke[G] }}
                            Gen.Fill(oO)(fill)
                        });
                        },
                    Hit: function (oO) { this.Fill(oO,['H']) },
                    Get: function (oO) { this.Fill(oO,['G']) },
                    Stimul: function (G) { return Gen.NukeCharStimul(this,G) },
                });

            Gen.NukeCharStimul = (oO, char) => {
                let { nuke} = oO || {nuke:{O:[]}}
                let CharEater = Char => Eater => {
                    const r = [...Char]
                    const g = list => list.reduce(f,0)
                    const f = (counter, G) => counter + h(G)
                    const h = Eater
                    return g(r);
                    }
                let ObjectNukeSizer = G =>
                    Object.keys(nuke).reduce(
                        (power, g) => power +
                        (nuke[g]
                            .join('')
                            .match(new RegExp(G,"g"))
                            || []
                        ).length
                        ,0);
                return CharEater(char)(ObjectNukeSizer);
                };
        };

        
        log( "AcidWeed Test ['RRFF', 'RRGG', 'RFFF']:", Gen.AcidWeed(['RRFF', 'RRGG', 'RFFF']) )

        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ The Person

        const NoblePerson = function
        (dna) {
            const Noble = Object.assign(this,dna)
            Noble.Story = [Noble.name||'Was born Noble',{dna}]
            Noble.SayHi = f=> log({Hi:Noble.Story[0], ...Noble})
            Gen.Welcome(Noble)
        };


        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ The Game

        const GameBegins = function
        (dna) {
            const Game = Object.assign(this,dna)
            
        };

        const NobleGame = function NobleGameFactory
        (dna) {
            const Noble = Object.assign(this,dna)
            Noble.Story = [Noble.name||'GameController',{dna}]
            Noble.SayHi = f=> log({Hi:Noble.Story[0], ...Noble})

            Noble.stages = ['RoundRobin','RoundGet','RoundFix','RoundHit']

            Noble.Reset = () => {
                Noble.currentTouch = 0
                Noble.currentStage = 0
                Noble.currentSquad = 0
                Noble.currentSheep = [0,0]
                Noble.currentScore = [0,0]
            }
            Noble.Reset()
            Noble.CurrentStageName = f => Noble.stages[Noble.currentStage]
            Noble.CurrentStageUpdate = f => {
                Noble.currentStage ++
                if (Noble.currentStage>= Noble.stages.length)
                    Noble.currentStage = 1
            }
            Noble.CurrentSquadChange = f =>
                { Noble.currentSquad = Noble.currentSquad ? 0:1 }
            Noble.CurrentSheepChange = f =>
                { Noble.currentSheep[Noble.currentSquad] =
                ++Noble.currentSheep[Noble.currentSquad] %3 }

            Noble.Start = (SquadA, SquadB) => {
                Noble.Reset()
                let Squad = f => [SquadA, SquadB][Noble.currentSquad]
                let Stage = f =>  Noble.stages[Noble.currentRound]
                let Sheep = f =>  Squad()[Noble.currentSheep[Noble.currentSquad]]
                let Ball = {inPlay:true};

                while( Ball.inPlay && Noble.currentTouch<6 ) {
                    Noble.currentTouch++
                    log('Noble.currentTouch',Noble.currentTouch)
                    Ball = Noble[Noble.stages[Noble.currentStage]]( Ball, Sheep() )
                }
                log('score',Noble.currentScore)
                log('touch',Noble.currentTouch)
            };

            Noble.RoundRobin = (Ball, Player) => {
                console.groupCollapsed('RoundRobin '+Noble.currentScore.join(':'))
                Ball = new NoblePerson(
                    TheWorld.GivesPassportFor('Ball #' +
                   (Noble.currentScore.reduce((B,l)=>l+B,1)) )
                )
                Gen.Fill(Ball)({nuke:Gen.Nuke(1)})
                TheWorld.DisplaysNuke(Ball)

                // Touch
                const passed = N=>N.H>N.G
                Ball.inPlay = true
                Player.Hit(Ball)

                // Results
                let hit = Ball.Stimul('H')
                let get = Ball.Stimul('G')
                let success = passed({H:hit,G:get})

                // Log
                TheWorld.DisplaysNuke(Player, Ball)
                console.groupEnd()
                log(Player.name, 'hit the ball')
                if (success) log('succes', {hit,get})
                if(!success) log('serve failed', {hit,get})

                // End
                if(!success) Noble.currentScore[ Noble.currentSquad ? 0:1 ]++
                if (success) Noble.CurrentStageUpdate()
                Noble.CurrentSheepChange()
                if (success) Noble.CurrentSquadChange()
                Ball.inPlay = !!success
                return Ball;
            };
            Noble.RoundGet = (Ball, Player) => {
                console.groupCollapsed('RoundGet')

                const passed = N=>N.G>N.H
                Ball.inPlay = true
                TheWorld.DisplaysNuke(Ball)
                Player.Get(Ball)

                let hit = Ball.Stimul('H')
                let get = Ball.Stimul('G')
                let success = passed({H:hit,G:get})

                // Log
                TheWorld.DisplaysNuke(Player, Ball)
                console.groupEnd('RoundGet')
                log( Player.name, 'get the ball')
                if (success) log('succes', {hit,get})
                if(!success) log('failed', {hit,get})

                // End
                if(!success) Noble.currentScore[ Noble.currentSquad ? 0:1 ]++
                if (success) Noble.CurrentStageUpdate()
                Noble.CurrentSheepChange()
                Ball.inPlay = !!success
                return Ball;
            };
            Noble.RoundFix = (Ball, Player) => {
                console.group('RoundFix')
                console.log('currentScore',Noble.currentScore)
                console.log('currentSquad',Noble.currentSquad)
                console.log('currentSheep',Noble.currentSheep)
                console.groupEnd('RoundFix')
                Ball.inPlay = false
                return Ball;
            }
        };

        let TheGame = new NobleGame()
        TheGame.SayHi()

        //const TestGameRun = f => {
            let TeamA = [
                new NoblePerson(TheWorld.GivesPassportFor('A1')),
                new NoblePerson(TheWorld.GivesPassportFor('A2')),
                new NoblePerson(TheWorld.GivesPassportFor('A3')),
                ];
            let TeamB = [
                new NoblePerson(TheWorld.GivesPassportFor('B1')),
                new NoblePerson(TheWorld.GivesPassportFor('B2')),
                new NoblePerson(TheWorld.GivesPassportFor('B3')),
                ];
            let Ball = new NoblePerson(TheWorld.GivesPassportFor('Ball'))
            const LevelUp = oO => {
                let nuke = {
                    R: [Gen.Gene('R'),Gen.Gene('R')],
                    G: [Gen.Gene('G'),Gen.Gene('G')],
                    F: [Gen.Gene('F'),Gen.Gene('F')],
                    H: [Gen.Gene('H'),Gen.Gene('H')],
                }
                Gen.Fill(oO)({nuke})
            }
            LevelUp(TeamA[0])
            LevelUp(TeamB[0])
            LevelUp(TeamA[1])
            LevelUp(TeamB[1])

            let score = [0,0]
            TheGame.RoundRobin(Ball,TeamA[0])
            if(!Ball.inPlay) {
                score[1]++;
                TheGame.RoundRobin(Ball,TeamB[0])
                if(!Ball.inPlay) {
                    score[0]++;
                } else {
                    TheGame.RoundGet(Ball,TeamA[1])
                    if(!Ball.inPlay) {
                        score[1]++;
                    }
                }
            } else {
                TheGame.RoundGet(Ball,TeamB[0])
                if(!Ball.inPlay) {
                    score[0]++;
                    TheGame.RoundRobin(Ball,TeamA[1])
                    if(!Ball.inPlay) {
                        score[1]++;
                    } else {
                        TheGame.RoundGet(Ball,TeamB[1])
                        if(!Ball.inPlay) {
                            score[0]++;
                        }
                    }
                }

            }
            log('score',score)

        //};
        //TestGameRun();

        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

        const NobleSheep = function NobleSheepFactory
        (...genes) {
            const Noble = Object.assign(this, ...genes)
            Noble.Profile = f => log({NobleSheep:'Â·',...Noble})
            Noble.Display = f => {
                console.group(['NobleSheep',Noble.name || ''].join(': '))
                Noble.Profile()
                for (i in Noble.nuke) log(i, Noble.nuke[i])
                console.groupEnd()
                }
            Noble.nuke = genes.nuke || GEN.Nuke()

            Noble.NukeFill = (dna, base) => {
                const  r = Object.keys(dna.nuke).slice(0, GEN.PACE);
                const  g = x => x.reduce(f, {})
                const  f = (a,b) => (a[b]=h(b),a);
                const  h = G => [GEN.Gene(G)];
                dna.nuke = {...dna.nuke, ...g(r)}
                //dna.nuke = Object.keys(dna.nuke).map(G=>GEN.Gene(G))
                }

            Noble.GenePower = G => {
                const NUKE = Noble.nuke
                const GPower = g =>
                    Object.keys(NUKE).reduce(
                        (power, key) => power +
                        (NUKE[key]
                            .join('')
                            .match(new RegExp(g,"g"))
                            || []
                        ).length
                        ,0);
                return [...G].reduce( (p,g) => p+GPower(g) , 0)
            };

            // run
            Noble.NukeFill(Noble)
        };

        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Run



        /**/ // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ End

        const GeneFactory = function() {
            let DNA  = this
            DNA.SEED ='RGFHIAEO'
            DNA.BASE ='RGFH'
            DNA.GeneSeed = base => {
                const  r = DNA.BASE;
                const  g = x => x[0]+f(x)+f(x)+f(x);
                const  f = x => x[Math.floor( Math.random()*x.length )];
                const  h = base ||f(r);
                return g(h+r);
            };
        }
        const GeneFactoryTest = function(GeneFactory) {
            let X = new GeneFactory()
            let GeneSeedF1 = r => Array.from('123456789012').map(x=>X.GeneSeed(r))
            log('GeneSeed R/G/F/H');
            log(GeneSeedF1('R'))
            log(GeneSeedF1('G'))
            log(GeneSeedF1('F'))
            log(GeneSeedF1('H'))
        }
        const SheepFactory = function() {
            let DNA  = this
            DNA.code = {r:[],g:[],f:[],h:[]}
            DNA.FillCode = (code) => {
                let i = 'r'
                const isFreeBase = !code[i].length
                const lastGene = code[i][code[i].length-1]
                const inviteChar = isFreeBase ? i : lastGene[3]
            }
            
        };
/*
RGFH
MBPT
IAE

arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);

sheep
ship
    nuke
        rgfh
        e:  exp, game played
        a:  atf, focus points
        i:  ini, initiative
        o:  empty
    pool
        

        s:  svg
            mods:
                r*r*:

        const GeneFactory = function() {
            let DNA  = this
            DNA.SEED ='RGFH'
            DNA.BornGene = base => {
                const  f = x => Math.floor( Math.random()*x.length )
                const  g = x =>(base||x[f(x)])+x[f(x)]+x[f(x)]+x[f(x)]
                return g(DNA.SEED)
            }
            DNA.GeneCreate = base => {
                const  f = x => x[Math.floor( Math.random()*x.length )]
                const  g = x => x[0]+f(x)+f(x)+f(x)
                let seed = DNA.SEED
                let head = base || f(seed)
                return g(head+seed)
            }
            DNA.GrowGene = blob => {
                const { gene, next } = blob
            }
            DNA.JoinPair = pair => {
                // const { a, b, }
            }
        };
*/


        const lib = {
            GeneEvents: {
                R: [
                    {
                        name:'RR Double Run',
                        rule: G => G[3] === 'R',
                    },
                    {
                        name:'RH Hit & Run',
                        rule: G => G[3] === 'H',
                    },
                ],
            },
        };
        const GeneEvents = {
            R:Gene => {
                let R = lib.GeneEvents.R
                let G = Gene // mix
                let F = GeneEvent => GeneEvent.rule
                let H = GeneEvent => log(GeneEvent.name)
                let action = R => F(R)(G) && H(R)
                R.map(action)
            }
        }
//        GeneEvents.R('RRGHH0')
//        let X = new GeneFactory()
//
//        console.log('X Gene', X.GeneSeed('X'))
//        console.log('D Gene', X.GeneSeed())
//
//        const sheep = {
//            AR:[X.GeneSeed('R')],
//            BG:[X.GeneSeed('G')],
//            PF:[X.GeneSeed('F')],
//            TH:[X.GeneSeed('H')]
//        }
//        tab(sheep)
//        GeneFactoryTest(GeneFactory);


        TheGame.Start(TeamA, TeamB)

    </script>
    <!-- 
    <script>
        let org = {
            M: []
          , B: []
          , P: []
          , T: []
        }
        GameActions = {
            R: G => {
                // G[0]
                // G[3]
                // G[2]
                if (G[3]==='R') console.log('RR Double Run')
            }
        }
        GameAction['R']
        let org = {
            R: [ 'RGFH' , 'HGFH' ],
            G: [ 'GGFH' ],
            F: [ 'FGFH' ],
            H: [ 'HGFH' ],
        }
        let org = [
            ['MRRR', 'RGFH']
          , ['BGGG', 'GGFH']
          , ['PFFF', 'FGFH']
          , ['THHH', 'HGFH']
        ]
        const A = {
            DNA : 'MBPT'
          , MAP : 'RGFH'
        }
        const MBPT = 'MBPT';
        const RGFH = 'RGFH';
        let gene = 'RGFH';
        let root = MBPT[RGFH.indexOf(gene[0])];
        let next = 'HGFH'

        const godmode = {
            g: i => gene[i]
          , G: gene
        }
        let { g } = godmode;
        
        let root = MBPT[RGFH.indexOf(G[1])];

        /**/gene = 'RGFH'
        let pair = {
            init : gene[0] + gene[1]
          , acid : gene[2] + gene[3]
          , exit : gene[4] + gene[5]
        }
        let set1 = [ 'init', 'acid', 'exit' ]

        let  = 'RGFH'

        let fun1 = gene => {
            
        }
        let gene = {
            init : 'A',
            acid : 'RGFH',
            exit : '0'
        }
        let gene = acid => {
            
        }
    </script>
     -->
</body>
</html>