<script>
    let help = {T:'Help'}
/** ADF
132 231 330
321 303 312
033 213 123
**/
//CHAR X
//GENE XXX
//ACID [XXX,XXX,XXX]

// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
const PickListItemIndex = list => Math.floor( Math.random()*list.length )
const PickListItem = list => list[PickListItemIndex(list)]
const MakeListSafe  = (list,skip) => list.filter(item=>!skip.includes(item))
const UT = {
  PickListItemIndex,
  PickListItem,
  MakeListSafe,
}
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
const CHARSEED = 'ADFGHLMST'
const CHARPOOL = [...CHARSEED]
const CHARDATA = {
    char: {
        A:'Aina', D:'Dina', F:'Funi',
        G:'Gina', H:'Hina', L:'Lina',
        M:'Mina', S:'Sina', T:'Tina',
        },
    chars: {
        A:[...'ABC'], D:[...'D'  ], F:[...'FU' ],
        G:[...'G'  ], H:[...'HJ' ], L:[...'L'  ],
        M:[...'M'  ], S:[...'S'  ], T:[...'T'  ],
        },
    charm: {
        A:1132, D:1231, F:1330,
        G:1321, H:1303, L:1312,
        M:1033, S:1213, T:1123,
        },
}; // CHARDATA eof
const CharExctract = (char,data)=> (O,key)=>({...O, [key]:data[key][char] })
const CharRibosome = G=> D=> Object.keys(D).reduce(CharExctract(G[0],D),{G}) //(CHAR)(DATA)
const HarmRibosome = G=> D=> ({harm:[...`${D['charm'][G]}`].slice(1).map(x=>x*1)}) //(CHAR)(DATA)
const MakeRibosome = G=> D=> ({  //(CHAR)(DATA)
  A:{ make:[
      { T:'Content CRM' },
      { T:'Update config' },
      { T:'Automized deploy' },
      ],
    },
    D:{ make:[
        { T:'Experienced trick' },
        { T:'HotFix' },
        { T:'Skip check' },
        ],
      },
      F:{ make:[
          { T:'Cheat' },
          { T:'Push master' },
          { T:'Discuss' },
          ],
        },
  G:{ make:[
      { T:'Block issue' },
      { T:'Outsource' },
      { T:'Demo presentation' },
      ],
    },
    H:{ make:[
        { T:'Keep' },
        { T:'Develop' },
        { T:'Skip Reports' },
        ],
      },
      L:{ make:[
          { T:'Delegate' },
          { T:'Use libs' },
          { T:'Full test' },
          ],
        },
  M:{ make:[
      { T:'Rush' },
      { T:'Block' },
      { T:'Documentation' },
      ],
    },
    S:{ make:[
        { T:'Deep view' },
        { T:'Research' },
        { T:'Detailed check' },
        ],
      },
      T:{ make:[
          { T:'Reject' },
          { T:'Refactoring' },
          { T:'Backlog' },
          ],
        },
})[G[0]];// MakeRibosome eof
const GEM = Object.values(CHARDATA.char).reduce(
  (OO,GEM)=> (G=> ({
    ...OO,
      [G]: {
        ...CharRibosome(G)(CHARDATA),
        ...HarmRibosome(G)(CHARDATA),
        ...MakeRibosome(G)(CHARDATA),
      },
  }))(GEM[0]), {} );
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
const CharPick = ({pool}) => {
  let list = pool || CHARPOOL
  let char = UT.PickListItem(list)
  return char;
};
const PoolSafe = ({pool,skip}) => {
  let source = pool || []
  let except = skip || []
  let result = UT.MakeListSafe(source,except)
  return [...result];
};
const GeneMake = ({pool,skip}) => {
  let source = pool || [...CHARPOOL]
  let except = skip || []
  let P = E => PoolSafe({pool:source,skip:[...except,...E]})
  let A = CharPick({ pool:P([]) })
  let B = CharPick({ pool:P([A]) })
  let C = CharPick({ pool:P([A,B]) })
  return [A,B,C].join('')
};
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
const VariantViewer =O=> {
  let GenA = GeneMake({})
  let GenB = GeneMake({skip:GenA})
  console.log('GenA/GenB:',GenA,GenB)
  console.log('GEMS:',GEM)
}; // VariantViewer eof
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
VariantViewer()
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
const ATF_MATRIX = {
  A:132, D:231, F:330,
  G:321, H:303, L:312,
  M:033, S:213, T:123,
}
const ATF = {
  A:{G:1,F:3,H:2}, D:{G:2,F:3,H:1}, F:{G:3,F:3,H:0},
  G:{G:3,F:2,H:1}, H:{G:3,F:0,H:3}, L:{G:3,F:1,H:2},
  M:{G:0,F:3,H:3}, S:{G:2,F:1,H:3}, T:{G:1,F:2,H:3},
}



/*


const acidseed = 'Oina Tina Sina Mina Hina Gina Aina Funi'
const acid = acidseed.split(' ')
const aminacid = acid.map(o=>o[0])//.join('')

const uIndexPick = list => Math.floor( Math.random()*list.length )
const acidPick = (acid) => acid[uIndexPick(acid)]
const acidMix3 = (acid = aminacid) => {
    const ne = taken => o=>taken!==o
    const take = acidPick(acid)
    const make = acidPick(acid.filter(ne(take)))
    const give = acidPick(acid.filter(ne(take)).filter(ne(make)))
    return [take,make,give].join('Â·')
}

*/

    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    // Create
    // Reveal
    // Update
    // Delete
    // Read
    // Reload
    // Review
    // Reread
    // Report
    // Raiden
/*
    GM.Serve()
    MTO: {M:4,T:2,O:8,H:2,L:6,G:2}
    HLG: {M:7,T:4,O:2,H:9,L:2,G:6}

    do { Touch() }
    while GM.active
    const Touch =O=> {
        let bumba
            squad
            touch
            rules
        if (touch) Get() else Serve()
        Update(bumba,{progress,assignee})
        {
            progress: touch,
            assignee: squad[field][touch]
        }
        Map rules.MakeEventsHappen
            event => {b,s,t} => Update(bumba,{comment})
        Commit(bumba)
        //
    Party
        squad: [[O],[O]],
        score: [0,0],
        bumba: {O},
        stage: [],
        nuke
            .stage: [],
        Stage
    services
        StageReveal ,// stage[last]
        StageCreate ,// stage.push
        StageFinish ,// stage[last] => Stage.Update({finish})
        PartyWelcome // nuke.dna -> transcription party
        SquadRegister
        SquadReorder // ([a, ...bc]) => ([...bc, a])
        TargetSheep

    Stage
        transcription (dna)
            bumba: {O},
            score: [0,0],
            field: 0,
            touch: 0,
            touchCounter: 0,
            ...dna
        DNA.transcription =
        dna => ({
            ...Object.assign(this, model, dna)
        });

        Touch
    services
        Welcome
            set nuke = nuke.dna

        ScoreUpdate
        TouchCreate
        TouchResolve
            Party.SquadReorder(Squad)
            Stage.StageIsComplete
        StageReset (dna)
        StageIsComplete // score >= 21
    
    Touch
    services
        Squad: Party.Squad[field]
        Sheep: Party.Squad[field][touch]
    run
    const Touch =O=> {
        // fin
        Stage.ScoreUpdate(score)
        Stage.TouchResolve()
    }
    const Touch =O=> {
        set
            sheep:squad
        
        KB.GetTask({assignee})
        UI.ProvideTouch({Stage})
        touchProvide
        touchRequest
        touchRespons
        resolve
            set touch
    };


*/

/*

let DNA:{[key:string]:any} = {}
let DNA = this
let Transcription 
DNA.transcription =
dna => ( seed => Object.assign(this, seed, dna);
dna => ({
    ...Object.assign(this, model, dna)
});

    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const Stage = function (dna) {
        let Transcription = rna => ( //: GEN.T
            model => Object.assign(this, model, {O:this,model})
        )({ //: GEN.M
            bumba: {},
            score: [0,0],
            field: 0,
            touch: 0,
            touchCounter: 0,
         ...(dna||{}),
         ...(rna||{}),
        });
        const { O:Stage, bumba:Bumba } = Transcription({Transcription})
        Stage.History =O=> console.log('Stage.History:', O);
        Stage.Profile =O=> console.log('Stage.Profile:', Stage);
        Stage.Welcome =O=>
            ( ([DNA]) =>{
                DNA.Transcription({...DNA.model, ...O})
                DNA.History({D:'Welcome Stage', O:DNA})
            })([Stage]);
        Stage.ScoreUpdate =O=>
            ( ([DNA]) =>{
                DNA.score = (([q,p]) => ([d,b]) => [ !d?q:q+1, !b?p:p+1 ])(DNA.score)(O.score)
                DNA.History({D:'Current Score', O:DNA.score})
            })([Stage]);
    };

    const kanbanTaskStory = {
        data: '',
    };
    const kanbanTaskComment = {
        name: '',
    };
    const kanbanTaskState = {
        estimate: 0,
        assignee: false,
        resolved: false,
        progress: 'backlog', //todo//inprogress//done//
        comments: [kanbanTaskComment],
    };
    const kanbanTask = {
        story: [kanbanTaskStory],
        state: [kanbanTaskState],
        nuke:{
            type: 'feat', //bugs//
            init: kanbanTaskState,
            state: [kanbanTaskState],
        },
    };
    const { pushAndReturn } = {
        pushAndReturn:( //=> pushAndReturn(item)(list,constructor)
            ([R,C])=> O=> ([b,c,d])=> (d||R(O))(b.push((c||C)(O)))
        )([
            O=> i=> ({ ...O, i:--i }), // <= default return format
            O=> O,                  // <= default item constructor
        ]),
    }
    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const KanbanBoard = function(dna) {
        const {
            O:DNA,
            tasks,
            state,
        }=( model => Object.assign(this, model, dna)
        )({ O:this,
            tasks: [],
            state: [],
         ...dna
        });
        DNA.test =O=> dna.test && dna.test(O||DNA)
        DNA.makeTask =O=> ({...O, ...kanbanTask, ...O})
        DNA.takeTask =O=> ( p=> ([b,d]) => (p)(b.push(d(O))) )(i=>({O,i:--i}))([tasks, DNA.makeTask])
        DNA.takeTask =O=> pushAndReturn(O)([tasks, DNA.makeTask, 0])
        DNA.giveTask =O=> tasks[O?.i||0]
        DNA.giveList =O=> tasks
        DNA.dsAssignee =O=> O?.state?.assignee ||0
        DNA.isAssignee =O=> O?.state?.assignee !==false
        DNA.isResolved =O=> O?.state?.resolved !==false

    };
    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const TASKS = [
        {title: 'Investigate incoming ball'},
    ].map( o=> ({...o, ...kanbanTask, ...o}) );
    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const KanbanBoardOld = function(dna) {
        const {
            O:DNA,
            tasks,
            story,
        }=( nuke => Object.assign( this,dna,{nuke} ))({
            O:this,
            tasks: [],
            story: [],
         ...dna.nuke,
             }).nuke;
        DNA.test =O=> dna.test && dna.test(O||DNA)
        DNA.makeTask =O=> ({...O, ...kanbanTask, ...O})
        DNA.takeTask =O=> (l=>({O,i:--l}))(tasks.push(DNA.makeTask(O)))
        DNA.giveTask =O=> tasks[O?.i||0]
        DNA.giveList =O=> tasks
        DNA.dsAssignee =O=> O?.state?.assignee ||0
        DNA.isAssignee =O=> O?.state?.assignee !==false
        DNA.isResolved =O=> O?.state?.resolved !==false

    };

*/
</script>