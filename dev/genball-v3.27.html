<script>
/*
123 132 330
213 231 303
312 321 033
CHAR X
GENE XXX
ACID [XXX,XXX,XXX]


303 312 321
     F
132 330 231

123 213 033

132 231 330
321 303 312
033 213 123
*/

const ATF_MATRIXi = {
  A:243, D:342, F:441,
  G:432, H:414, L:423,
  M:144, S:324, T:234,
}
const ATF_MATRIX = {
  A:132, D:231, F:330,
  G:321, H:303, L:312,
  M:033, S:213, T:123,
}
const ATF = {
  A:{G:1,F:3,H:2}, D:{G:2,F:3,H:1}, F:{G:3,F:3,H:0},
  G:{G:3,F:2,H:1}, H:{G:3,F:0,H:3}, L:{G:3,F:1,H:2},
  M:{G:0,F:3,H:3}, S:{G:2,F:1,H:3}, T:{G:1,F:2,H:3},
}
const Vitamins = {
  A:{ char:'Aina',
      chars:[...'ABC'],
      charm: 132,
      moves:{
        G:{T:'Content CRM'},
        F:{T:'Update config'},
        H:{T:'Automized deploy'},
      },
    },
    D:{ char:'Dina',
        chars:[...'D'],
        charm: 231,
        moves:{
          G:{T:'Experienced trick'},
          F:{T:'HotFix'},
          H:{T:'Skip test'},
        },
      },
      F:{ char:'Funi',
          chars:[...'F'],
          charm: 330,
          moves:{
            G:{T:''},
            F:{T:''},
            H:{T:''},
          },
        },
  G:{ char:'Aina',
      chars:[...'ABC'],
      charm: 132,
      moves:{
        G:{T:'Content CRM'},
        F:{T:'Update config'},
        H:{T:'Automized deploy'},
      },
    },
    H:{ char:'Dina',
        chars:[...'D'],
        charm: 231,
        moves:{
          G:{T:'Experienced trick'},
          F:{T:'HotFix'},
          H:{T:'Skip test'},
        },
      },
      L:{ char:'Funi',
          chars:[...'F'],
          charm: 330,
          moves:{
            G:{T:''},
            F:{T:''},
            H:{T:''},
          },
        },
}

const PickListItemIndex = list => Math.floor( Math.random()*list.length )
const PickListItem = list => list[PickListItemIndex(list)]
const MakeListSafe  = (list,skip) => list.filter(candidate=>!skip.filter(taken=>taken===candidate))
const UT = {
  PickListItemIndex,
  PickListItem,
  MakeListSafe,
}

const CHARSEED = 'TGFLSDAHM'
const CHARPOOL = [...CHARSEED]

const CharPick = ({pool}) => {
  let list = pool || CHARPOOL
  let char = UT.PickListItem(list)
  return char;
};

const PoolSafe = ({pool,skip}) => {
  let list = pool || CHARPOOL
  let except = skip || []
  let listSafe = UT.MakeListSafe(list,except)
  return [...listSafe];
};

const GeneMake = ({pool}) => {
  let gene = [...'XXX']
  gene[0] = CharPick({pool:PoolSafe({pool,skip:gene})})
  gene[1] = CharPick({pool:PoolSafe({pool,skip:gene})})
  gene[2] = CharPick({pool:PoolSafe({pool,skip:gene})})
  return gene.join('')
};


const run = () => {
  let tim1 = GeneMake()
  let pool = PoolSafe({skip:tim1})
  let tim2 = GeneMake({pool})
  let poo2 = PoolSafe({skip:pool})
  console.table({
    team1: tim1,
    team2: tim2,
    poolC: poo2,
  })
}




const acidseed = 'Oina Tina Sina Mina Hina Gina Aina Funi'
const acid = acidseed.split(' ')
const aminacid = acid.map(o=>o[0])//.join('')

const uIndexPick = list => Math.floor( Math.random()*list.length )
const acidPick = (acid) => acid[uIndexPick(acid)]
const acidMix3 = (acid = aminacid) => {
    const ne = taken => o=>taken!==o
    const take = acidPick(acid)
    const make = acidPick(acid.filter(ne(take)))
    const give = acidPick(acid.filter(ne(take)).filter(ne(make)))
    return [take,make,give].join('Â·')
}


    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    // Create
    // Reveal
    // Update
    // Delete
    // Read
    // Reload
    // Review
    // Reread
    // Report
    // Raiden
/*
    GM.Serve()
    MTO: {M:4,T:2,O:8,H:2,L:6,G:2}
    HLG: {M:7,T:4,O:2,H:9,L:2,G:6}

    do { Touch() }
    while GM.active
    const Touch =O=> {
        let bumba
            squad
            touch
            rules
        if (touch) Get() else Serve()
        Update(bumba,{progress,assignee})
        {
            progress: touch,
            assignee: squad[field][touch]
        }
        Map rules.MakeEventsHappen
            event => {b,s,t} => Update(bumba,{comment})
        Commit(bumba)
        //
    Party
        squad: [[O],[O]],
        score: [0,0],
        bumba: {O},
        stage: [],
        nuke
            .stage: [],
        Stage
    services
        StageReveal ,// stage[last]
        StageCreate ,// stage.push
        StageFinish ,// stage[last] => Stage.Update({finish})
        PartyWelcome // nuke.dna -> transcription party
        SquadRegister
        SquadReorder // ([a, ...bc]) => ([...bc, a])
        TargetSheep

    Stage
        transcription (dna)
            bumba: {O},
            score: [0,0],
            field: 0,
            touch: 0,
            touchCounter: 0,
            ...dna
        DNA.transcription =
        dna => ({
            ...Object.assign(this, model, dna)
        });

        Touch
    services
        Welcome
            set nuke = nuke.dna

        ScoreUpdate
        TouchCreate
        TouchResolve
            Party.SquadReorder(Squad)
            Stage.StageIsComplete
        StageReset (dna)
        StageIsComplete // score >= 21
    
    Touch
    services
        Squad: Party.Squad[field]
        Sheep: Party.Squad[field][touch]
    run
    const Touch =O=> {
        // fin
        Stage.ScoreUpdate(score)
        Stage.TouchResolve()
    }
    const Touch =O=> {
        set
            sheep:squad
        
        KB.GetTask({assignee})
        UI.ProvideTouch({Stage})
        touchProvide
        touchRequest
        touchRespons
        resolve
            set touch
    };


*/
let DNA:{[key:string]:any} = {}
let DNA = this
let Transcription 
DNA.transcription =
dna => ( seed => Object.assign(this, seed, dna);
dna => ({
    ...Object.assign(this, model, dna)
});

    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const Stage = function (dna) {
        let Transcription = rna => ( //: GEN.T
            model => Object.assign(this, model, {O:this,model})
        )({ //: GEN.M
            bumba: {},
            score: [0,0],
            field: 0,
            touch: 0,
            touchCounter: 0,
         ...(dna||{}),
         ...(rna||{}),
        });
        const { O:Stage, bumba:Bumba } = Transcription({Transcription})
        Stage.History =O=> console.log('Stage.History:', O);
        Stage.Profile =O=> console.log('Stage.Profile:', Stage);
        Stage.Welcome =O=>
            ( ([DNA]) =>{
                DNA.Transcription({...DNA.model, ...O})
                DNA.History({D:'Welcome Stage', O:DNA})
            })([Stage]);
        Stage.ScoreUpdate =O=>
            ( ([DNA]) =>{
                DNA.score = (([q,p]) => ([d,b]) => [ !d?q:q+1, !b?p:p+1 ])(DNA.score)(O.score)
                DNA.History({D:'Current Score', O:DNA.score})
            })([Stage]);
    };

    const kanbanTaskStory = {
        data: '',
    };
    const kanbanTaskComment = {
        name: '',
    };
    const kanbanTaskState = {
        estimate: 0,
        assignee: false,
        resolved: false,
        progress: 'backlog', //todo//inprogress//done//
        comments: [kanbanTaskComment],
    };
    const kanbanTask = {
        story: [kanbanTaskStory],
        state: [kanbanTaskState],
        nuke:{
            type: 'feat', //bugs//
            init: kanbanTaskState,
            state: [kanbanTaskState],
        },
    };
    const { pushAndReturn } = {
        pushAndReturn:( //=> pushAndReturn(item)(list,constructor)
            ([R,C])=> O=> ([b,c,d])=> (d||R(O))(b.push((c||C)(O)))
        )([
            O=> i=> ({ ...O, i:--i }), // <= default return format
            O=> O,                  // <= default item constructor
        ]),
    }
    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const KanbanBoard = function(dna) {
        const {
            O:DNA,
            tasks,
            state,
        }=( model => Object.assign(this, model, dna)
        )({ O:this,
            tasks: [],
            state: [],
         ...dna
        });
        DNA.test =O=> dna.test && dna.test(O||DNA)
        DNA.makeTask =O=> ({...O, ...kanbanTask, ...O})
        DNA.takeTask =O=> ( p=> ([b,d]) => (p)(b.push(d(O))) )(i=>({O,i:--i}))([tasks, DNA.makeTask])
        DNA.takeTask =O=> pushAndReturn(O)([tasks, DNA.makeTask, 0])
        DNA.giveTask =O=> tasks[O?.i||0]
        DNA.giveList =O=> tasks
        DNA.dsAssignee =O=> O?.state?.assignee ||0
        DNA.isAssignee =O=> O?.state?.assignee !==false
        DNA.isResolved =O=> O?.state?.resolved !==false

    };
    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const TASKS = [
        {title: 'Investigate incoming ball'},
    ].map( o=> ({...o, ...kanbanTask, ...o}) );
    // ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    const KanbanBoardOld = function(dna) {
        const {
            O:DNA,
            tasks,
            story,
        }=( nuke => Object.assign( this,dna,{nuke} ))({
            O:this,
            tasks: [],
            story: [],
         ...dna.nuke,
             }).nuke;
        DNA.test =O=> dna.test && dna.test(O||DNA)
        DNA.makeTask =O=> ({...O, ...kanbanTask, ...O})
        DNA.takeTask =O=> (l=>({O,i:--l}))(tasks.push(DNA.makeTask(O)))
        DNA.giveTask =O=> tasks[O?.i||0]
        DNA.giveList =O=> tasks
        DNA.dsAssignee =O=> O?.state?.assignee ||0
        DNA.isAssignee =O=> O?.state?.assignee !==false
        DNA.isResolved =O=> O?.state?.resolved !==false

    };
</script>